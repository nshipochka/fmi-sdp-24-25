# Речници
- **Абстрактна структура от данни**, която съхранява двойки ключ-стойност.
- Може да бъде реализиран чрез хеш таблици, балансирани дървета или други структури.

### Хеш таблици
- **Конкретна реализация** на структура от данни, базирана на масив и хеш функции.
- Служи за ефективно съхранение и извличане на данни с приблизителна сложност **O(1)** за повечето операции.
- Проблемът с хеш таблиците е справянето с **колизии** (когато два ключа водят до един и същи индекс в масива).

#### Хеш функции
Хеш функциите са алгоритми, които преобразуват ключове в цели числа, използвани като индекси в таблицата.

Какво наричаме **"добра" хеш функция**? 
- функция, при която има **малка вероятност за колизия**.  
- Функцията трябва да използва **всички данни от key**.  
- За **"подобни" ключове**, функцията връща **"напълно различни" индекси**.  
- **Равномерна функция** (броят на колизиите на всеки индекс е относително еднакъв).  
- **Бърза за изчислване**.

## Примери за речници в STL
### `std::map`
- Реализира се чрез **балансирано дърво** (обикновено черно-червено дърво).
- Поддържа ключовете **сортирани**.
- Сложност: O(log n) за **вмъкване**, **търсене** и **изтриване**.
- Поддържа **уникални ключове**.

### `std::unordered_map`
- Реализира се чрез **хеш таблица**.
- Ключовете не са сортирани, но операциите са по-бързи в среден случай.
- Сложност: O(1) за **вмъкване**, **търсене** и **изтриване** в средния случай; O(n) в най-лошия случай.
- Поддържа **уникални ключове**.

### `std::multimap`
- Реализира се чрез **балансирано дърво**.
- Поддържа ключовете **сортирани**.
- Позволява **повтарящи се ключове**.
- Сложност: O(log n) за **вмъкване**, **търсене** и **изтриване**.

### Сравнение
| Характеристика       | `std::map`   | `std::unordered_map` | `std::multimap` |
|----------------------|--------------|-----------------------|-----------------|
| Структура            | Дърво        | Хеш таблица          | Дърво           |
| Подреденост          | Да           | Не                   | Да              |
| Уникалност на ключовете | Да           | Да                   | Не              |
| Сложност за операции | O(log n)     | O(1) / O(n)          | O(log n)        |

---

## Колизии

Колизиите възникват, когато две различни ключа имат една и съща хеш стойност. Това се случва при:
- Ограничен размер на таблицата
- Неоптимална хеш функция

### Методи за справяне с колизии
#### Open Addressing
- Всички елементи се съхраняват директно в масива. Ако има колизия, се търси следващата свободна позиция чрез:
    - Линейно пробиране: Търси следващата позиция последователно.
    - Квадратично пробиране: Използва квадратни стъпки за търсене на нова позиция.
    - Двойно хеширане: Използва втора хеш функция за намиране на нова позиция.
- Пести памет
- При натоварена таблица може да доведе до голямо забавяне.

```c++
    #include <iostream>
    #include <vector>

    class HashTable {
        static const int TABLE_SIZE = 10;
        std::vector<std::pair<int, std::string>> table;
        std::vector<bool> occupied;

    public:
        HashTable() : table(TABLE_SIZE, {-1, ""}), occupied(TABLE_SIZE, false) {}

        size_t hashFunction(int key) {
            return key % TABLE_SIZE;
        }

        void insert(int key, const std::string& value) {
            size_t index = hashFunction(key);
            while (occupied[index]) {
                index = (index + 1) % TABLE_SIZE;  // Линейно пробиране
            }
            table[index] = {key, value};
            occupied[index] = true;
        }

        std::string search(int key) {
            size_t index = hashFunction(key);
            size_t start = index;
            while (occupied[index]) {
                if (table[index].first == key) {
                    return table[index].second;
                }
                index = (index + 1) % TABLE_SIZE;
                if (index == start) break;
            }
            return "Not found";
        }

        void remove(int key) {
            size_t index = hashFunction(key);
            size_t start = index;
            while (occupied[index]) {
                if (table[index].first == key) {
                    table[index] = {-1, ""};
                    occupied[index] = false;
                    return;
                }
                index = (index + 1) % TABLE_SIZE;
                if (index == start) break;
            }
        }
    };
```

#### **Separate Chaining**
- Всеки елемент в хеш таблицата съдържа указател към списък, където се съхраняват всички двойки с една и съща хеш стойност
- Лесно за реализиране
- При твърде много колизии производителността се влошава        

```c++
    #include <iostream>
    #include <vector>
    #include <list>

    class HashTable {
        static const int TABLE_SIZE = 10;
        std::vector<std::list<std::pair<int, std::string>>> table;

    public:
        HashTable() : table(TABLE_SIZE) {}

        size_t hashFunction(int key) {
            return key % TABLE_SIZE;
        }

        void insert(int key, const std::string& value) {
            size_t index = hashFunction(key);
            table[index].emplace_back(key, value);
        }

        std::string search(int key) {
            size_t index = hashFunction(key);
            for (const auto& pair : table[index]) {
                if (pair.first == key) {
                    return pair.second;
                }
            }
            return "Not found";
        }

        void remove(int key) {
            size_t index = hashFunction(key);
            table[index].remove_if([key](const std::pair<int, std::string>& pair) {
                return pair.first == key;
            });
        }
    };
```

## Задачи
## Задача 1
Даден е масив от думи. Намерете честотата на всяка дума.  

**Пример**:  
```
Вход: ["apple", "banana", "apple", "orange", "banana", "apple"] 
Изход: { "apple": 3, "banana": 2, "orange": 1 }
```


---

## Задача 2
Даден е масив от двойки `(обект, категория)` по категории. Групирайте ги по категории.

**Пример**:  
```
Вход: [("apple", "fruit"), ("carrot", "vegetable"), ("banana", "fruit"), ("broccoli", "vegetable")]
Изход: { "fruit": ["apple", "banana"], "vegetable": ["carrot", "broccoli"] }
```

---

## Задача 3
Направете замяна на символи в текст според дадени правила.  

**Пример**: 
```
Вход: 
    текст: "hello world"
    правила: { "h": "H", "e": "3", "o": "0" }
Изход: "H3ll0 w0rld"
```

---

## Задача 4
Намерете двойка числа от даден масив, която се сумира до дадено число `sum`.

**Пример**:  
```
Вход: 
    масив: [8, 7, 2, 5, 3, 1]
    sum: 10
Изход: (0, 2), (1, 4)
``` 

---

## Задача 5
Намерете всички симетрични двойки в масив от двойки числа

**Пример**:  
```
Вход: [(3, 4), (1, 2), (5, 2), (7, 10), (4, 3), (2, 5)]
Изход: (4, 3) и (3, 4), (2, 5) и (5, 2)
```

---

## Задача 6
Проверете дали два низа са изоморфни.

Два низа са изоморфни, ако можем да заменим всички срещания на един символ в единия стринг със символ от другия и така за всички символи, докато не получим два еднакви низа.

**Пример**:  
```
Вход: ACAB и XCXY
Изход: да

Вход: ACCB и XCXY
Изход: не
```

