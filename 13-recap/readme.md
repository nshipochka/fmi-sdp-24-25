# Задача 1
Двупосочен път в ориентиран граф наричаме път, в който всяко ребро има обратно, т.е. огледалният образ на пътя също е път в графа. 

Да се напишат следните функции:
- void loadGraph (char *name, IntGraph& g), която създава графа g от текстов файл с име name, организиран по следния начин: на всеки ред от файла има две числа, разделени с интервал. Първото число задава начало на ребро, а второто - неговия край.

- bool maxTwoWayFrom (int n, IntGraph& g, int length), която проверява дали от възела n започва огледален път с дължина най-малко length.

- bool pathN(int n, IntGraph& g, int length), която проверява дали в ориентирания граф g съществува ацикличен път с дължина поне length, започващ от върха n. 

# Задача 2
Да се напишат следните функции, работещи с линеен едносвързан списък. Ако се използва реализация, различна от използваната на лекции или упражнения, тя трябва да се опише.
а) int count (T& a, списък<T>), която намира броя на срещанията на елемент в списък
б) void remove (T& a, списък<T>), която премахва всички срещания на елемент от списък
в) hist (списък), която по даден списък отпечатва на екрана двойки с честотата на срещанията на всеки негов елемент
Пример: hist [1, 2, 3, 1, 5, 3] ~> 1, 2 \ 2, 1 \ 3, 2 \ 5,1

# Задача 3
Нека са дадени дърво и опашка. Да се дефинира функцията bool levelCheck (дърво t, опашка q, int level), която проверява дали всички елементи от опашката q могат да бъдат прочетени от дясно на ляво в нивото level на дървото t, в реда, в който са достъпни от опашката.

# Задача 4
Да се напише функция, която проверява дали в даден граф има път от възел a до възел b с дължина точно k и ако такъв има, го връща като резултат.

# Задача 5
Даден е едносвързан списък от двусвързани списъци от числа. Да се намери броя на двусвързаните списъци, които са палиндроми, т.е. се четат еднакво отпред назад и отзад напред.

# Задача 6
Да се напише функция, която проверява дали даден граф съдържа цикъл, и ако съдържа, връща един такъв като резултат.

# Задача 7
Даден е ориентиран граф G, представен чрез списък от наследници. Да се намери ацикличен път p от a до b, за който е изпълнено следното условие: в графа G съществува път от b до a, който включва само и единствено върхове от пътя p. Ако такъв път не съществува, да се върне празен път.

